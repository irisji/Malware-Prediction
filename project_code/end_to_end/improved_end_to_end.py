import pandas as pd
import numpy as np

class MyPredictor:
    
    with_eng = False
    
    def __init__(self,with_eng):
        
        self.df = df
        self.with_eng = with_eng
    

        self.ignore_cols = ['HasDetections','MachineIdentifier','OsBuildLab','Census_ChassisTypeName','Census_InternalBatteryType','Census_OSEdition','Census_OSSkuName']
        self.enc_cols = []
        self.std_cols = []
        self.nrm_cols = []

        self.categoric_cols = []
        self.numeric_cols = []
        self.others = []

        self.mode = {}

    def info(self,df):
        metaData = df.describe(include='all')

        self.describe_df = pd.DataFrame()
        self.describe_df['count'] = df.count()
        self.describe_df['uniques'] = df.nunique()
        self.describe_df['dtype'] = df.dtypes
        self.describe_df['missing'] = 1 - df.count() /  len(df)
        self.describe_df.sort_values(by='missing', ascending=False).head(20)
        return self.describe_df
    
    def groupCols(self,x):
        if x.name in self.ignore_cols:
            pass
        elif x['missing'] > 0.3:
            self.ignore_cols.append(x.name)
        elif x['uniques'] < 50:
            self.categoric_cols.append(x.name)
        elif str(x['dtype']).startswith('int') or str(x['dtype']).startswith('float') and not x.name.endswith('Identifier'):
            self.numeric_cols.append(x.name)
        else:
            self.others.append(x.name)
    
    def preClean(self,df):
        # delete rows: delete row with 80% missing x value and no y value
        df= df.copy()
        df.dropna(thresh = 64, inplace = True)
        df.reset_index(drop = True, inplace =True)
        df.dropna(subset =['HasDetections'], inplace = True)
        df.reset_index(drop = True, inplace =True)
    
        return df
    
    def splitOsBuildLab(self,x):
        y = str(x).split('.')
        try:
            y = y[2]
        except:
            return''
        return y   
    
    def groupChassis(self,x):
        if str(x).lower()=='':
            return ''
        elif ('desktop' or 'pc') in str(x).lower():
            return 'desktop'
        elif ('notebook'or 'laptop' or 'tablet') in str(x).lower():
            return 'notebook'
        elif ('portable'or 'handheld') in str(x).lower():
            return 'portable'
        elif 'allinone'in str(x).lower():
            return 'allInOne'
        elif 'tower'in str(x).lower():
            return 'tower'
        elif 'convertible'in str(x).lower():
            return 'convertible'
        elif 'detachable'in str(x).lower():
            return 'detachable'
        elif 'spacesaving'in str(x).lower():
            return 'spaceSaving'
        elif 'chassis'in str(x).lower():
            return 'chassis'
        elif 'box'in str(x).lower():
            return 'box'
        elif 'unknown'in str(x).lower():
            return ''
        else:
            return x

    
    def groupBattery(self,x):
        if str(x).lower().strip()=='':
            return ''
        elif ('liio' or 'lion' or 'li-i' or 'ithi') in str(x).lower().strip():
            return 'lithium-ion'
        elif 'lip' in str(x).lower().strip():
            return 'Lithium_polymer'
        elif 'nimh' in str(x).lower().strip():
            return 'Nickelâ€“metal_hydride'
        elif ('nan' or 'unk' )in str(x).lower().strip():
            return ''
        else:
            return x
    
    def osGroup(self,x):
            if str(x) == '':
                return ''
            if 'professional' in str(x).lower():
                return 'professional'
            elif 'core' in str(x).lower():
                return 'core'
            elif 'server' in str(x).lower():
                return 'server'
            elif 'cloud' in str(x).lower():
                return 'cloud'
            elif 'enterprise' in str(x).lower():
                return 'enterprise'
            elif 'education' in str(x).lower():
                return 'education'
            elif 'ultimate' in str(x).lower():
                return 'ultimate'
            elif 'unlicensed' in str(x).lower():
                return 'unlicensed'
            elif 'workstation' in str(x).lower():
                return 'workstation'
            else:
                return x
    
    def featureEng(self,df):
        df = df.copy()

        for i, x in enumerate(df.columns.tolist()):
            if str(x).endswith('Identifier')&(str(x) != 'MachineIdentifier'):
                top_30 = df[[x,'MachineIdentifier']].groupby(x).count()\
                .div(df[x].count()).sort_values(by='MachineIdentifier', ascending=False)\
                .cumsum().iloc[0:30].index.tolist()
                df[x+'Combined']=[i if i in top_30+[np.nan] else 'other' for i in df[x]]
                 
            elif str(x).endswith('Version'):
                #print('version',x,df[x].isnull().sum())
                _df = pd.DataFrame(np.array(df[x].str.split('.').tolist()))
  
                for i in range(4):
                    df[x+str(i+1)]=_df[i]
                    
            else:
                self.ignore_cols.append(x)
        
            
       
        df['OsBuildLab1'] = df['OsBuildLab'].apply(lambda x: self.splitOsBuildLab(x))
        
       
        df['Census_ChassisTypeName1']=df['Census_ChassisTypeName'].apply(lambda x: self.groupChassis(x))

       
        df['Census_InternalBatteryType1']=df['Census_InternalBatteryType'].apply(lambda x: self.groupBattery(x))

        
        df['Census_OSEdition1']=df['Census_OSEdition'].apply(lambda x: self.osGroup(x))
        df['Census_OSSkuName1']=df['Census_OSSkuName'].apply(lambda x: self.osGroup(x))
        
        return df
    
        
    def fit(self,df):
        df = df.copy()
        df = self.preClean(df)
        
        if self.with_eng:
            df = self.featureEng(df)

        #group columns
        self.describe_df = self.info(df)
        self.describe_df.apply(lambda x: self.groupCols(x), axis=1)
            

        '''
        # method1 cat <= mode, num <= median
        for name in self.categoric_cols:
            self.mode[name] = df[name].mode(dropna = True)[0]
        for name in self.numeric_cols:
            self.mode[name] = df[name].median()
        for name in self.enc_cols:
            self.mode[name] = df[name].mode(dropna = True)[0]
        for name in self.std_cols:
            self.mode[name] = df[name].mode(dropna = True)[0]
        if self.nrm_cols != []
            for name in self.nrm_cols:
            self.mode[name] = df[name].mode(dropna = True)[0]
        '''
        
        #medthod2 all <= mode
        self.mode = {i: df[i].mode()[0] for i in df.columns.tolist()}

        # prepare columns for encoding
        self.enc_cols = list(set(self.categoric_cols +self.enc_cols) - set(self.ignore_cols))
        self.std_cols = list(set(self.numeric_cols + self.std_cols) - set(self.ignore_cols))

        # Encoding
        self.enc = OneHotEncoder(handle_unknown='ignore', sparse=False)
        self.enc.fit(df[self.enc_cols].fillna(self.mode).astype('str').values)
        self.std = StandardScaler()
        self.std.fit(df[self.std_cols].fillna(self.mode).values)
        if self.nrm_cols != []:
            self.nrm = Normalizer()
            self.nrm.fit(df[self.nrm_cols].fillna(self.mode).values)
        
        # Transform
        X = self.transform(df)
        
        # Fit model
        self.linear_model = LogisticRegression()
        self.linear_model.fit(X, df['HasDetections'])
   
    def transform(self,df):

        X1 = self.enc.transform(df[self.enc_cols].fillna(self.mode).astype('str').values)
        X2 = self.std.transform(df[self.std_cols].fillna(self.mode).values)
        if self.nrm_cols != []:
            X3 = self.nrm.transform(df[self.nrm_cols].fillna(self.mode).values)
            return np.hstack((X1,X2,X3))
        else:

            return np.hstack((X1,X2))
    
    def predict(self,df):
        df= df.copy()
        df = self.preClean(df)

        if self.with_eng:
            df = self.featureEng(df)    
        self.enc_cols = list(set(self.enc_cols))
        self.nrm_cols = list(set(self.nrm_cols))
        self.std_cols = list(set(self.std_cols))
        X = self.transform(df)
        y_p_linear = self.linear_model.predict(X)
        y_t_linear = df['HasDetections']
        return y_p_linear, y_t_linear
        